##ES6学习
####async函数
https://blog.csdn.net/tcy83/article/details/80544048
async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。返回的是一个promise函数
说明await后面是支持非Promise函数的，但是执行的结果是不一样的，所以await针对所跟的表达式不同，有两种处理方式：

1、对于Promise对象，await会阻塞主函数的执行，等待 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果，然后继续执行主函数接下来的代码。

2、对于非Promise对象，await等待函数或者直接量的返回，而不是等待其执行结果。

####CommonJs module 规范和 ES6 module 规范
一、ES6规范  
1.export 可以输出任何数据类型，但必须要有{ }，一个模块里可以使用多次   
2.export default 可以输出默认值，不需要{ }，一个模块里只能使用一次  
3.import的{ } 和export对应

二、CommonJs规范  
1.module.export 只能输出一个值，且后者会覆盖前者  
2.exports 可以输出多个值  

三、两者区别  
1.ES6是解析阶段生成接口，CommonJs是运行阶段生成接口，加载模块  
2.ES6的模块不是对象，加载的不是对象，CommonJs的模块是对象，加载的是该对象  
3.ES6输出的是值的引用，值改变，引用也改变，即原来模块中的值改变则该加载的值也改变。CommonJs输出的是值的拷贝，即原来模块中的值改变不会影响已经加载的该值。  
4.ES6的this指向undefined，CommonJs的this指向当前模块。


####变量的解构赋值
解构赋值允许指定默认值。右边的值一定要多于左边
#####一、数组的解构赋值
``` js
let [a, b, c] = [1, 2, 3];
```
如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。
另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。
``` js
let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
```
#####二、对象的解构赋值
``` js
let { foo, bar } = { foo: "aaa", bar: "bbb" };
foo // "aaa"
bar // "bbb"
```
#####字符串的解构赋值
#####数值和布尔值的解构赋值
#####函数参数的解构赋值
#####圆括号问题
#####用途
（1）交换变量的值
（2）从函数返回多个值
（3）函数参数的定义
（4）提取 JSON 数据
（5）函数参数的默认值
（6）遍历 Map 结构
（7）输入模块的指定方法

####字符串的扩展
#####模板字符串
#####方法扩展
>includes()：返回布尔值，表示是否找到了参数字符串。
startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。
endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。
repeat()方法返回一个新字符串，表示将原字符串重复n次。
ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。
matchAll方法返回一个正则表达式在当前字符串的所有匹配，
####正则的扩展
####数值的扩展
####函数的扩展
#####函数参数的默认值
#####rest 参数 
``` js
function add(...values) {
  let sum = 0;

  for (var val of values) {
    sum += val;
  }

  return sum;
}

add(2, 5, 3) // 10
```
注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。
#####严格模式
#####箭头函数

####数组的扩展
Array.from()方法用于将两类对象转为真正的数组：值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。
Array.of()方法用于将一组值，转换为数组。
####对象的扩展
目前，有四个操作会忽略enumerable为false的属性。
* for...in循环：只遍历对象自身的和继承的可枚举的属性。
* Object.keys()：返回对象自身的所有可枚举的属性的键名。
* JSON.stringify()：只串行化对象自身的可枚举的属性。
* Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。
#####Object.is()
ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。

ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。

#####__proto__属性
__proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11）都部署了这个属性。
Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。
该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。

#####Object.keys()，Object.values()，Object.entries()

for...in循环主要是为遍历对象而设计的，不适用于遍历数组。
for...of循环相比上面几种做法，有一些显著的优点。
有着同for...in一样的简洁语法，但是没有for...in那些缺点。
不同于forEach方法，它可以与break、continue和return配合使用。
提供了遍历所有数据结构的统一操作接口。

####Generator函数
* Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。
* yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。
* for...of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。
* 除了for...of循环以外，扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。


####跨域处理
1.通过jsonp跨域,只能实现get请求        
3、 nginx代理跨域
4、 nodejs中间件代理跨域
5、 后端在头部信息里面设置安全域名，普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置

####ES6小知识
#####1、let和const的区别
* let:let声明的变量只在let命令所在的代码块内有效。声明的变量仅在块级作用域
* const:声明一个只读的常量。一旦声明，常量的值就不能改变。只在声明所在的块级作用域内有效。
* ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。
#####2、箭头函数与this
* 全局环境中，this会返回顶层对象。但是，
* 模块和ES6模块中，this返回的是当前模块。
函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。
* ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式”下还是会报错。ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。
ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。(声明不会被提升)

* 箭头函数有几个使用注意点。
（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。
（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。

#####3、ES6数据类型
* ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。