####Ajax
######axios
######fetch
######async函数
async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。

#######Promise

Promise通过then方法进行链式调用，resolve和reject结果


#######跨域处理
1.通过jsonp跨域,只能实现get请求        
3、 nginx代理跨域
4、 nodejs中间件代理跨域
5、 后端在头部信息里面设置安全域名，普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置

######1、let和const命令
* let:let声明的变量只在let命令所在的代码块内有效。声明的变量仅在块级作用域
* const:声明一个只读的常量。一旦声明，常量的值就不能改变。只在声明所在的块级作用域内有效。
* ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。
<pre>
var a = 1;
// 如果在Node的REPL环境，可以写成global.a
// 或者采用通用方法，写成this.a
window.a // 1
let b = 1;
window.b // undefined
上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。
</pre>
* 全局环境中，this会返回顶层对象。但是，
* 模块和ES6模块中，this返回的是当前模块。
函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。
* ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式”下还是会报错。ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。
ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。(声明不会被提升)
箭头函数有几个使用注意点。

（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。

（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。

（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。

（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。
</pre>
######6.ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。
####CommonJs module 规范和 ES6 module 规范

一、ES6规范  
1.export 可以输出任何数据类型，但必须要有{ }，一个模块里可以使用多次   
2.export default 可以输出默认值，不需要{ }，一个模块里只能使用一次  
3.import的{ } 和export对应

二、CommonJs规范  
1.module.export 只能输出一个值，且后者会覆盖前者  
2.exports 可以输出多个值  

三、两者区别  
1.ES6是解析阶段生成接口，CommonJs是运行阶段生成接口，加载模块  
2.ES6的模块不是对象，加载的不是对象，CommonJs的模块是对象，加载的是该对象  
3.ES6输出的是值的引用，值改变，引用也改变，即原来模块中的值改变则该加载的值也改变。CommonJs输出的是值的拷贝，即原来模块中的值改变不会影响已经加载的该值。  
4.ES6的this指向undefined，CommonJs的this指向当前模块。